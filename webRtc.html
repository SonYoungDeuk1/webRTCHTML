<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
    <title></title>
    <script type="text/javascript" src="js/socket.io.js"></script>
    <script type="text/javascript" charset="utf-8">
        /** 신호 참고: 소켓 연결 1개*/
        //socket
        //var socket = io('ws://172.16.70.226:8081');
        var socket = io('wss://www.webrtcdeuk.tk:8443');
        //local socket ID
        var socketId;
        //room id
        var roomId;

        /** RTCPeerConnection 참고: 화상 채팅방의 다른 여러 클라이언트에는 여러 개의 RTCPeerConnection 연결이 있습니다.*/
        //RTCPeerConnection 연결 저장
        var rtcConnects = {};
        //ice server
        var config = {
            'iceServers': [{ 'url': 'stun:stun.xten.com' }]
        };
        var offerOptions = {
            offerToReceiveAudio: 1,
            offerToReceiveVideo: 1
        };

        //local stream
        var localStream = null;

        /** UI 작업 */
        //채팅방 생성 및 참여
        function createAndJoinRoom() {
            var roomName = $('roomName').value;
            if (roomName) {
                //【createAndJoinRoom] 방 만들기 및 참여 [방]
                socket.emit('createAndJoinRoom', { room: roomName })
            } else {
                console.log('채팅방명을 입력해주세요');
            }
        }

        //채팅방 나가기 [from,room]
        function exit() {
            
            var data = {};
            data.from = socketId;
            data.room = roomId;
            socket.emit('exit', data);
            
            $('createAndJoinRoom').disabled = false;
            //데이터 재설정
            socketId = '';
            roomId = '';
            //peer폐쇄
            for (var i in rtcConnects) {
                var pc = rtcConnects[i];
                pc.close();
                pc = null;
            }
            rtcConnects = {};
            //원격 카메라 제거
            $('remoteDiv').innerHTML = '';
        }

        /** WebRtc */
        //webRtc연결 빌드 및 반환
        function getOrCreateRtcConnect(socketId) {
            var pc = rtcConnects[socketId];
            if (typeof (pc) == 'undefined') {
                //RTCPeerConnection
                pc = new RTCPeerConnection(config);
                //icecandidate
                pc.onicecandidate = e => onIceCandidate(pc, socketId, e);
                // pc.onaddstream = e => onAddStream(pc, socketId, e);
                // if (localStream != null) {
                //     //peer로컬 스트림 설정
                //     pc.addStream(localStream);
                // }

                
                pc.ontrack = e => onTrack(pc, socketId, e);
                if (localStream != null) {
                    //peer로컬 스트림 설정
                    localStream.getTracks().forEach(function(track) {
                         pc.addTrack(track, localStream);
                    });
                }
                //peer 스트림 데이터를 가져오도록 콜백 설정
                pc.onremovestream = e => onRemoveStream(pc, socketId, e);
                //peer 연결 저장
                rtcConnects[socketId] = pc;
            }
            return pc;
        }

        //webRtc연결 제거
        function removeRtcConnect(socketId) {
            delete rtcConnects[socketId];
        }

        //로컬 카메라 스트림 바인딩
        function gotStream(stream) {
            console.log('Received local stream');
            $('localVideo').srcObject = stream;
            localStream = stream;
        }

        /** WebRtc RTCPeerConnection */
        //icecandidate정보 콜백 받기
        function onIceCandidate(pc, id, event) {
            //시그널링 서버로 보내기 candidate [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]
            console.log('onIceCandidate to ' + id + ' candidate ' + event);
            if (event.candidate != null) {
                var message = {};
                message.from = socketId;
                message.to = id;
                message.room = roomId;
                var candidate = {};
                candidate.sdpMid = event.candidate.sdpMid;
                candidate.sdpMLineIndex = event.candidate.sdpMLineIndex;
                candidate.sdp = event.candidate.candidate;
                message.candidate = candidate;
                socket.emit('candidate', message);
            }
        }

        function onAddStream(pc, id, event) {
            console.log('onAddStream from ' + id);
            //동적으로 video 생성   <video id="localVideo" style='width:450px;height:350px;' autoplay></video>
            //$('remoteDiv').innerHTML += `<video id="${id}" style='width:200;height:200;' autoplay></video>`;
            var video = document.createElement('video');
            video.id = id;
            video.autoplay = 'autoplay';
            video.style.width = 200;
            video.style.height = 200;
            video.style.marginRight = 5;
            $('remoteDiv').appendChild(video);
            $(id).srcObject = event.stream;
        }

        //peer stream데이터 콜백--onTrack 모델
        function onTrack(pc, id, event) {
            console.log('onTrack from ' + id);
            //동적으로 video 생성   <video id="localVideo" style='width:450px;height:350px;' autoplay></video>
            //$('remoteDiv').innerHTML += `<video id="${id}" style='width:200;height:200;' autoplay></video>`;
            var video = document.createElement('video');
            video.id = id;
            video.autoplay = 'autoplay';
            video.style.width = 200;
            video.style.height = 200;
            video.style.marginRight = 5;
            $('remoteDiv').appendChild(video);
            $(id).srcObject = event.streams[0];
        }

        //onRemoveStream
        function onRemoveStream(pc, id, event) {
            console.log('onRemoveStream from ' + id);
            getOrCreateRtcConnect(id).close;
            //peer삭제
            delete rtcConnects[id];
            //video 제거
            $('remoteDiv').removeChild($(id));
        }

        //offer 성공 콜백 만들기
        function onCreateOfferSuccess(pc, id, offer) {
            console.log('createOffer: success ' + ' id:' + id + ' offer ' + JSON.stringify(offer));
            //setLocalDescription
            pc.setLocalDescription(offer);
            var message = {};
            message.from = socketId;
            message.to = id;
            message.room = roomId;
            message.sdp = offer.sdp;
            socket.emit('offer', message);
        }

        //offer 실패 콜백 생성
        function onCreateOfferError(pc, id, error) {
            console.log('createOffer: fail error ' + error);
        }

        //answer 성공 콜백 만들기
        function onCreateAnswerSuccess(pc, id, offer) {
            console.log('createAnswer: success ' + ' id:' + id + ' offer ' + JSON.stringify(offer));
            //setLocalDescription
            pc.setLocalDescription(offer);
            var message = {};
            message.from = socketId;
            message.to = id;
            message.room = roomId;
            message.sdp = offer.sdp;
            socket.emit('answer', message);
        }

        //answer 실패 콜백 생성
        function onCreateAnswerError(pc, id, error) {
            console.log('createAnswer: fail error ' + error);
        }

        /** 시그널링socket모니터링 */
        //created [id,room,peers]
        socket.on('created', async function (data) {
            console.log('created: ' + JSON.stringify(data));
            $('createAndJoinRoom').disabled = true;
            //socket id 설정
            socketId = data.id;
            //room id 설정
            roomId = data.room;
            // WebRtcPeerConnection을 만들고 응답 peer 루프를 기반으로 offer 메시지 전송[from,to,room,sdp]
            for (let i = 0; i < data.peers.length; i++) {
                var otherSocketId = data.peers[i].id;
                //WebRtcPeerConnection 생성
                var pc = getOrCreateRtcConnect(otherSocketId);
                //offer 설정
                const offer = await pc.createOffer(offerOptions);//pc.createOffer(offerOptions).then(offer => onCreateOfferSuccess(pc, otherSocketId, offer), error => onCreateOfferError(pc, otherSocketId, error));
                onCreateOfferSuccess(pc, otherSocketId, offer);
                // (function(pc, otherSocketId){
                //     pc.createOffer(offerOptions).then(offer => onCreateOfferSuccess(pc, otherSocketId, offer), error => onCreateOfferError(pc, otherSocketId, error));
                // })(pc, otherSocketId);

            }
        })

        //joined [id,room]
        socket.on('joined', function (data) {
            console.log('joined: ' + JSON.stringify(data));
            //Peer생성
            getOrCreateRtcConnect(data.from);
        })

        //offer [from,to,room,sdp]
        socket.on('offer', function (data) {
            console.log('offer: ' + JSON.stringify(data));
            //peer open
            var pc = getOrCreateRtcConnect(data.from);
            //RTCSessionDescription 생성 
            var rtcDescription = { type: 'offer', sdp: data.sdp };
            //setRemoteDescription 원격설정
            pc.setRemoteDescription(new RTCSessionDescription(rtcDescription));
            //createAnswer
            pc.createAnswer(offerOptions).then(offer => onCreateAnswerSuccess(pc, data.from, offer), error => onCreateAnswerError(pc, otherSocketId, error));
        })

        //answer [from,to,room,sdp]
        socket.on('answer', function (data) {
            console.log('answer: ' + JSON.stringify(data));
            //peer open
            var pc = getOrCreateRtcConnect(data.from);
            //RTCSessionDescription생성
            var rtcDescription = { type: 'answer', sdp: data.sdp };
            //setRemoteDescription 원격설정
            pc.setRemoteDescription(new RTCSessionDescription(rtcDescription));
        })

        //candidate  [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]
        socket.on('candidate', function (data) {
            console.log('candidate: ' + JSON.stringify(data));
            var iceData = data.candidate;
            //Peer open
            var pc = getOrCreateRtcConnect(data.from);
            var rtcIceCandidate = new RTCIceCandidate({
                candidate: iceData.sdp,
                sdpMid: iceData.sdpMid,
                sdpMLineIndex: iceData.sdpMLineIndex
            });
            //Candidate peer 추가
            pc.addIceCandidate(rtcIceCandidate);
        })

        //exit [from,room]
        socket.on('exit', function (data) {
            console.log('exit: ' + JSON.stringify(data));
            //현재 연결인지 확인
            var pc = rtcConnects[data.from];
            if (typeof (pc) == 'undefined') {
                return;
            } else {
                //peer close
                getOrCreateRtcConnect(data.from).close;
                //peer 삭제
                delete rtcConnects[data.from];
                //video 제거
                $('remoteDiv').removeChild($(data.from));

            }
        })

        function $(id) {
            return document.getElementById(id);
        }

        //카메라 시작
        function startCamera() {
            //카메라 시작
            if (localStream == null) {
                navigator.mediaDevices
                    .getUserMedia({
                        audio: true,
                        video: true
                    })
                    .then(stream => gotStream(stream))
                    .catch(e => alert('getUserMedia() error: ${e.name}'));
            }
        }

        //카메라 시작
        startCamera();
    </script>
</head>

<body>
    <input type="text" id="roomName" placeholder="방제를 입력해 주세요." />
    <br/>
    <button id="createAndJoinRoom" onclick="createAndJoinRoom()">방생성 또는 참가하기</button>
    <br/>
    <button id="exit" onclick="exit()">나가기</button>
    <br/>
    <video id="localVideo" style='width:450px;height:350px;' autoplay></video>
    <br/>
    <div id='remoteDiv'></div>
</body>

</html>
